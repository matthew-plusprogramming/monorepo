import { writeFile } from 'node:fs/promises';
import { join } from 'node:path';

import { registerHook } from '../../utils/hooks.mjs';

const SCHEMAS_PACKAGE_JSON = [
  'packages',
  'core',
  'schemas',
  'package.json',
];

const APP_LAYER_PATH = [
  'apps',
  'node-server',
  'src',
  'layers',
  'app.layer.ts',
];

const buildChecklist = (context) => {
  const { config, selectedBundles, helpers } = context;
  const checklistConfig = config.checklist ?? {};
  const targetRelative = helpers.applyTokens(
    checklistConfig.target ??
      'scripts/output/repository-service/__ENTITY_SLUG__-checklist.md',
    {
      __SELECTED_BUNDLES__: selectedBundles.map((bundle) => bundle.name).join(
        ', ',
      ),
    },
  );

  const headerLines = (checklistConfig.headerLines ?? [
    '# Repository Service Checklist: __ENTITY_PASCAL__',
    '',
    '- Workflow reference: `agents/workflows/repository-service.workflow.md`',
    '- Generated by `scripts/create-repository-service.mjs` on __TIMESTAMP__',
    '- Selected bundles: __SELECTED_BUNDLES__',
    '',
  ]).map((line) =>
    helpers.applyTokens(line, {
      __SELECTED_BUNDLES__: selectedBundles
        .map((bundle) => bundle.name)
        .join(', '),
    }),
  );

  const lines = [...headerLines];

  for (const bundle of selectedBundles) {
    if (!Array.isArray(bundle.checklist)) continue;
    const resolved = bundle.checklist.map((line) => helpers.applyTokens(line));
    lines.push(...resolved, '');
  }

  if (lines.at(-1) === '') {
    lines.pop();
  }

  return {
    relativePath: targetRelative,
    content: lines.join('\n'),
  };
};

export const registerRepositoryServiceHooks = () => {
  registerHook(
    'postScaffold',
    'repositoryService.updateSchemasPackageJson',
    async (context) => {
      const { slug, flags, helpers, addReportEntry } = context;
      const targetPath = helpers.resolveOutput(...SCHEMAS_PACKAGE_JSON);

      const raw = await helpers.readFile(targetPath);
      const data = JSON.parse(raw);

      if (!data.exports || typeof data.exports !== 'object') {
        throw new Error(
          `Unable to update exports in ${helpers.relativeToOutput(
            targetPath,
          )}: missing "exports" field.`,
        );
      }

      const exportKey = `./${slug}`;
      const desiredExport = {
        types: `./dist/${slug}/index.d.ts`,
        import: `./dist/${slug}/index.js`,
      };

      const existingExport = data.exports[exportKey];
      const matchesExisting =
        existingExport &&
        existingExport.types === desiredExport.types &&
        existingExport.import === desiredExport.import;

      if (matchesExisting) {
        return { status: 'ok', notes: 'Schema export already present.' };
      }

      if (existingExport && !flags.force) {
        throw new Error(
          [
            `Export "${exportKey}" already exists in ${helpers.relativeToOutput(
              targetPath,
            )}.`,
            'Run again with --force to overwrite the existing export.',
          ].join(' '),
        );
      }

      const updatedExports = {
        ...data.exports,
        [exportKey]: desiredExport,
      };

      const sortedEntries = Object.entries(updatedExports).sort(([a], [b]) =>
        a.localeCompare(b),
      );

      data.exports = Object.fromEntries(sortedEntries);

      if (!flags.dryRun) {
        await writeFile(
          targetPath,
          `${JSON.stringify(data, null, 2)}\n`,
          'utf-8',
        );
      }

      addReportEntry({
        location: helpers.relativeToOutput(targetPath),
        action: existingExport ? 'updated export' : 'added export',
        skipped: Boolean(flags.dryRun),
        bundle: 'schemas-package',
      });

      return { status: 'ok' };
    },
  );

  registerHook(
    'postScaffold',
    'repositoryService.updateAppLayer',
    async (context) => {
      const { slugVariants, flags, helpers, addReportEntry } = context;
      const targetPath = helpers.resolveOutput(...APP_LAYER_PATH);
      const originalContent = await helpers.readFile(targetPath);

      const repositoryImportPattern =
        /^import { (Live[A-Za-z0-9]+Repo) } from '(@\/services\/[a-zA-Z0-9]+Repo\.service)';$/gm;

      const repositoryImports = new Map();
      let match;
      while ((match = repositoryImportPattern.exec(originalContent)) !== null) {
        repositoryImports.set(match[1], match[2]);
      }

      const importName = `Live${slugVariants.pascalCase}Repo`;
      const importPath = `@/services/${slugVariants.camelCase}Repo.service`;
      const alreadyPresent = repositoryImports.has(importName);

      if (!alreadyPresent) {
        repositoryImports.set(importName, importPath);
      }

      const sortedRepositoryImports = [...repositoryImports.entries()].sort(
        ([a], [b]) => a.localeCompare(b),
      );

      const repositoryImportLines = sortedRepositoryImports.map(
        ([name, path]) => `import { ${name} } from '${path}';`,
      );

      const headerImports = [
        "import { Layer } from 'effect';",
        '',
        "import { LiveDynamoDbService } from '@/services/dynamodb.service';",
        "import { LiveEventBridgeService } from '@/services/eventBridge.service';",
        "import { ApplicationLoggerService } from '@/services/logger.service';",
        ...repositoryImportLines,
        '',
      ];

      const repositoryNames = sortedRepositoryImports.map(([name]) => name);
      const providedVariableNames = repositoryNames.map(
        (name) => `${name}Provided`,
      );

      const providedConstants = repositoryNames.map(
        (name, index) =>
          `const ${providedVariableNames[index]} = ${name}.pipe(Layer.provide(Base));`,
      );

      const mergeCalls = providedVariableNames.map(
        (providedName) => `Layer.merge(${providedName})`,
      );

      const appLayerBlock =
        mergeCalls.length > 0
          ? `export const AppLayer = Base.pipe(
  ${mergeCalls.join(',\n  ')}
);`
          : 'export const AppLayer = Base;';

      const baseSection = `const Base = LiveDynamoDbService.pipe(
  Layer.merge(ApplicationLoggerService),
).pipe(Layer.merge(LiveEventBridgeService));`;

      const updatedContent = [
        ...headerImports,
        baseSection,
        '',
        ...providedConstants,
        '',
        appLayerBlock,
        '',
      ].join('\n');

      if (updatedContent === originalContent) {
        return { status: 'ok', notes: 'App layer already up to date.' };
      }

      if (!flags.dryRun) {
        await writeFile(targetPath, updatedContent, 'utf-8');
      }

      addReportEntry({
        location: helpers.relativeToOutput(targetPath),
        action: alreadyPresent ? 'normalized AppLayer' : 'updated AppLayer',
        skipped: Boolean(flags.dryRun),
        bundle: 'app-layer',
      });

      return { status: 'ok' };
    },
  );

  registerHook(
    'postScaffold',
    'repositoryService.runLintFix',
    async (context) => {
      const { flags, helpers, addReportEntry } = context;

      if (flags.dryRun) {
        console.log('ℹ️  Skipping `npm run lint:fix` (dry run).');
        addReportEntry({
          location: 'npm run lint:fix',
          action: 'skipped',
          skipped: true,
          bundle: 'post-process',
        });
        return { status: 'ok', notes: 'Lint fix skipped (dry run).' };
      }

      console.log('▶️  Running `npm run lint:fix` to format new scaffolding...');
      helpers.runCommand('npm', ['run', 'lint:fix']);

      addReportEntry({
        location: 'npm run lint:fix',
        action: 'executed',
        skipped: false,
        bundle: 'post-process',
      });

      return { status: 'ok' };
    },
  );

  registerHook(
    'postScaffold',
    'repositoryService.writeChecklist',
    async (context) => {
      const { flags, helpers, addReportEntry, selectedBundles } = context;
      const { relativePath, content } = buildChecklist(context);
      const targetPath = helpers.resolveOutput(relativePath);

      const writeOutcome = await helpers.writeFile(targetPath, content);

      addReportEntry({
        location: helpers.relativeToOutput(targetPath),
        action: writeOutcome.action,
        skipped: Boolean(writeOutcome.skipped),
        bundle: 'checklist',
      });

      return { status: 'ok' };
    },
  );
};

